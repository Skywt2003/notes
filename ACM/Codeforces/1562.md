

# Codeforces Round #741 (Div. 2)

## A. The Miracle and the Sleeper

## B. Scenes From a Memory

如果有 1、4、6、8、9 中的任何一个数字就保留这 1 个数字，否则如果有重复数字就保留 2 个重复数字，否则只剩下 2、3、5、7 四个数字且不重复，枚举判断素数即可。

## C. Rings

如果左半部分有 0 就取第一段带上 0 到结尾，第二段 0 后一位到结尾，右半部分的 0 开头开始同理。如果全是 1 就取 n-(n&1) 长度和 n/2 长度，必为 3 倍。

## D1. Two Hundred Twenty One (easy version)

### Description

对一个由 +1 和 -1 组成的序列 $a_i$，需要满足条件 $a_1 - a_2 + a_3 - a_4 + \ldots = 0$ 即 $\sum\limits_{i=1}^n (-1)^{i-1} \cdot a_i = 0$。

现在给出一个长度为 $n$ 的序列和 $q$ 次查询，对于每次查询 $l,r$，输出 $[l,r]$ 区间内最少删除多少个元素才可以使这个区间内剩下的序列满足上述条件。共 $t$ 组数据，$1 \le n, q \le 3 \cdot 10^5$。

### Thoughts

比赛的时候一直想的是直接把 $a_i * (-1)^{i-1}$ 预处理出一个数组 $c_i$，对这个 $c_i$ 进行处理，如果取出两个数字 $c_i,c_j$，则相当于将 $[i+1,j-1]$ 区间内的符号取反，如果取出一个数字 $c_i$ 相当于把 $[i+1,n]$ 区间符号取反。但是这样的想法没法满足答案的要求找到要取出几个，只是一种具体的实施方案。

其实应该回到原始的 $a_i$ 进行处理。果然我关于数学分析方面还是太薄弱了 QwQ……

### Analysis

观察样例输出发现，似乎每个查询的结果都是 0、1 或者 2，并且规律是：特判 0 之后，对于长度为奇数的查询，答案就是 1；长度是偶数答案就是 2。

有点像某年 NOIP 提高组的第一题，结论很简单，就看能不能观察出来、敢不敢写，证明起来还是有点难度的。下面证明：

现在考虑查询区间是 $[1,n]$，我们令 $b_i$ 为第 $i$ 个元素取出之后，剩余元素的「带符号和」（即 $\sum\limits_{i=1}^n (-1)^{i-1} \cdot a_i$）。

- **结论一：**如果 $a_i = a_{i+1}$，则 $b_i = b_{i+1}$。证明：如果 $a_i = a_{i+1}$，显然取出 $a_i$ 和取出 $a_{i+1}$ 得到的新数列是一样的。

- **结论二：**如果 $a_i \not= a_{i+1}$，则 $|b_i-b_{i+1}|=2$。证明：令 $f(i,j)$ 为 $[i,j]$ 区间内的「带符号和」，那么

  $$b_i = f(1,i-1) + a_{i+1} + f(i+2,n)$$

  $$b_{i+1} = f(1,i-1) + a_i + f(i+2,n)$$

  上式减去下式得到：$|b_i-b_{i+1}|=|a_i-a_{i+1}|=2$。

- **结论三：**对于一段长度为偶数的数列，其「带符号和」必然是偶数，因为每个元素的贡献是 1 或者 -1。反之，长度为奇数的数列「带符号和」是奇数。

- **结论四：**如果 $n$（查询长度）为奇数，必然存在至少一个 $b_i=0$。分类证明：

  - $b_1=0$ 或 $b_n=0$：显然满足；
  - （$b_1<0$ 且 $b_n>0$）或者（$b_1>0$ 且 $b_n<0$）：由于相邻 $b_i$ 之间的差值绝对值只可能是 0 或者 2（结论二），并且所有 $b_i$ 都是偶数（结论三），所以必然存在 $b_i=0$ 的情况；
  - （$b_1<0$ 且 $b_n<0$ ）或者（$b_1>0$ 且 $,_b>0$）：这两种情况不存在。设整个数列的「带符号和」是 $S$（这里不考虑 $S=0$ 的情况），则 $b_1=-S\pm 1$，$b_n=S\pm 1$，则显然两个数字符号相异。

- **结论五：**如果 $n$（查询长度）为偶数，不存在 $b_i=0$，因为 $b_i$ 必然是奇数。

综上，如果区间和为 0，答案是 0；否则对于长度为奇数的查询，答案为 1（结论四）；否则对于长度为偶数的查询，任意删除一个元素就可以变成长度为奇数的查询（结论四，长度为奇数必然有解）（结论五，答案不可能为 1），答案为 2。

这个证明真的很难想到……光是这个 $b_i$ 的定义就很奇妙了……

## D2. Two Hundred Twenty One (hard version)

### Description

在 D1 的基础上，要求输出删除的元素位置。

### Analysis #1

先考虑长度为奇数的情况，根据结论一和结论二，这个 $b_i$ 序列类似一个连续的函数，相邻元素差只能是 0、2 或 -2。又根据零点定理，可以二分搜索：如果 $b_l$ 和 $b_r$ 符号不同，则说明其中必然存在 $b_i=0$，取 $mid$，其又会和 $l,r$ 之一异号，借此缩小范围，直到找到 $b(mid)=0$。

如果长度是偶数，可以直接删除第一个元素，然后同上方法操作。

这种二分的运用算是第一次见，根据异号性查找，还是比较有新意的。

### Analysis #2

一个自己的想法，也是二分，但是没有利用零点定理这个性质。



## E. Rescue Niwen!

### Description

给出一个字符串 $s_1s_2\dots s_n$，使这个字符串「膨胀」之后得到多个字符串，分别是 $s_1$，$s_1s_2$，$s_1s_2s_3$，……，$s_1s_2\dots s_n$，$s_2$，$s_2s_3$，……，$s_2s_3\dots s_n$，……，$s_{n-1}s_n$，$s_n$，这些字符串构成一个序列。

你要输出这个序列的最长升子序列。$1 \le n \le 5000$。

多组数据，$1 \le t \le 10^3$。$n$ 的总和不超过 $10^4$。

### Thoughts

果然字符串算法是一点都不会了。

可以想到一个 DP 的做法：$F[i]$ 表示以 $s_i$ 开头的最长升序列，从后往前构造。$s_i$ 有默认权值 $w_i=n-i+1$（也就是字母 $i$ 开头的 $n-1$ 个字符串）。考虑状态转移：

- 对于 $s_i>s_j$ 的情况，不转移。
- 对于 $s_i<s_j$ 的情况，直接全部转移，$F[i]=max(F[i],F[j]+w_i)$。
- 对于 $s_i = s_j$ 的情况，比较复杂，探究发现需要考察 $s_{i+1}$ 和 $s_{j+1}$ 的情况：
  - 对于 $s_{i+1}>s_{j+1}$ 的情况，不转移。
  - 对于 $s_{i+1}<s_{j+1}$ 的情况，全部转移，但是要直接从 $F[j+1]$ 转移。
  - 对于 $s_{i+1}=s_{j+1}$ 的情况，继续考察 $s_{i+2}$ 和 $s_{j+2}$。
    - ……

这样理论上时间复杂度可以达到 $O(n^3)$。

冥冥之中感觉这个「前缀匹配」应该用某种字符串算法去优化，可是我啥都不会了。

### Analysis

<img src="/Users/skywt/Library/Application Support/typora-user-images/截屏2021-09-29 上午10.37.06.png" alt="截屏2021-09-29 上午10.37.06" style="zoom:25%;" />

一个 *2500 的题，搁这写论文呢？？？

#### Silly

有一种时间不满足但是十分简洁的做法：对所有 $n(n-1)/2$ 个字符串排序之后直接找 LIS。

#### 一个性质

由于字符串大小比较的「高位决定性」，首先可以得到一个性质：如果最长升序列中包含字符串 $[l,r]$，那么一定包含字符串 $[l,n]$。这个性质其实前面的想法里也发现了，只不过很难清晰地表述出来。

#### 前置知识：后缀数组

后缀数组主要是两个数组：$sa$ 和 $rk$。$sa[i]$ 表示第 $i$ 小的后缀的编号，$rk[i]$ 表示后缀 $i$ 的排名。满足 $sa[rk[i]]=rk[sa[i]]=i$。

$O(n^2log(n))$ 的做法：直接存好 $n$ 个后缀，字符串排序。由于字符串有长度，复杂度要多乘个 $n$。

#### 前置知识：LCP（最长公共前缀）

我们实际上要找后缀之间的最长公共前缀。



#### DP 优化

本质上的优化方法是：我们要以 $O(1)$ 的复杂度得知 $i,j$ 分别开头的字符串的最长公共前缀 $lcp(i,j)$。

状态转移：



$$F[i]=max\{F[j+lcp(i,j)-1] + w_i\}(s_i<s_j)$$





## F. Tubular Bells

