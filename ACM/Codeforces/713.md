# Codeforces Round #371 (Div. 1)



## A. Sonya and Queries

二叉树记录。

## B. Searching Rectangles

### Description

这是一道交互题。

给出 $n*n$ 的网格，其中有两个标记的长方形区域，保证无重叠。每次可以查询一个长方形区域内包含了几个标记的长方形（完全包含才算包含），返回的答案是 0、1 或者 2。询问次数不超过 200 次。

输出两个长方形区域的位置。

$n\le 2^{16}$。

### Thoughs

题目的这个 $n\le 2^{16}$ 强暗示要二分。

一开始的想法是通过二分可以分别定位两个矩形的各个边界（即延长两个矩形的各条边形成「大矩形」的边界），然后直接验证，如果不正确则交换两个矩形的左边界、右边界。

但是 Test#4 的这组数据把这个想法 hack 了：

```
10
1 1 10 1
5 5 5 10
```

现在看来，这种明显没有想清楚也没有证明的做法我是怎么有胆交 6 发的……

### Analysis

其实考虑如果只有一个长方形，问题就非常简单，直接用二分法可做。

现在有两个长方形，但是给出了一个保证：一定没有重叠。那么一定可以找到一条平行于 $x$ 轴或者 $y$ 轴的分界线，使得这条分界线把 $n*n$ 的网格分为两部分，每个部分各自独立包含一个完整的长方形。（这个是非常重要但是没有想到的性质 TAT）

首先可以二分枚举这个分界线，然后对于分出的两块，每块里只有一个矩形，二分可做。

## C. Sonya and Problem Wihtout a Legend

### Description

给出一个数列，每次操作你可以对其中任意一个元素 +1 或者 -1。要求最终将其变为严格单调递增数列。求最少需要的操作数。

$1\le n\le 3000$，$1\le a_i\le 10^9$。

### Analysis

- 先考虑这个问题的简化版：给出数列 $a_i$，如何用最少操作使得每个元素相等？其实就是如何确定一个 $x$ 使得 $\Sigma |a_i-x|$ 最小。

  答案是，使每个元素等于数列的中位数，即取 $x$ 为中位数。初中奥数「收费站」问题。

  - 如何动态维护一个前缀的这个答案？

    答案是，用两个堆维护中位数，一个大根堆，一个小根堆。使两个堆元素数量相等，则可以得到中位数。分别维护两个堆的和，可以得到操作数答案。

- 考虑简化问题的加强版：给出数列 $a_i$，如何用最少操作使得数列满足相差 $1$ 递增（即 $a_{i+1}=a_i+1$）？

  答案是，直接对一开始的 $a_i$ 操作，对 $a_i$ 减去 $i$，再按照第一个问题做。可以看成调整所有数字相等之后再把 $i$ 加回 $a_i'$。

- 回到这个问题。考虑 DP。

  - $F(i)$ 表示前 $i$ 个元素的答案，同时需要记录前 $i$ 个元素修改之后最后一个元素的最小值 $last_i$（因为最后一个值最小肯定保证之后最优，所以是唯一的，不需要纳入状态考虑）。

  - 对于 $F(i)$，枚举 $j$，考虑用 $F(i)$ 修正 $F(j)$，具体是假设 $[i+1,j]$ 这一段都相差 $1$ 递增（根据上面的思路预处理出 $delta(i,j)$）。

  - 能修正的条件是，调整之后 $a_{i+1}' > last_i$。事实上我们可以得到 $a_{i+1}'$，因为上面调整相差 $1$ 递增时，调整完毕后最小的数字（也就是排在第一个的 $a_{i+1}$）肯定是中位数+1（此处中位数指的是 $a_i-i$ 之后算的中位数）。构造 $delta(i,j)$ 时我们也可以存储中位数 $mid(i,j)$，满足 $mid(i+1,j)+1 > last_i$ 时则可以修正。

 

