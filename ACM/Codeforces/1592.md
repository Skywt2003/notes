# Codeforces Round #746 (Div. 2)

C 题还是比较可惜的。不过居然没掉绿，惊讶。

## A. Gamer Hemose

贪心，拿最强的两个武器交替使用。

## B. Hemose Shopping

### Description

给出一个长度为 $n$ 的数组，要求对其排序，条件是只能交换满足 $|i-j|\ge x$ 的 $a_i$ 和 $a_j$。问能否实现排序，输出 `YES` or `NO`。

多组数据。$1 \leq x \leq n \leq 10^5$。

### Thoughts

如果 $x\le \lfloor n/2\rfloor$，那么发现对于数组中的任意一个元素，可以自由调换到任意位置。则必然可以实现排序。

如果 $x>\lfloor n/2\rfloor$，可以发现对于中间下标 $[n-x+1,x]$ 这一段的数字是没有办法操作的。判断如果对于剩余数字操作之后能否使数组有序（即中间这段数字是否本来就在它们有序时应该在的位置上）。

## C. Bakry and Partitioning

### Description

给出一棵树，每个节点有一个值 $a_i$，你需要删除最少 $1$ 条边、最多 $k-1$ 条边，使得形成的每个联通块中的 $a_i$ 异或和相等。输出 `YES`or `NO`，是否有可能实现。

多组数据，$2\leq n \leq 10^5,\Sigma n\leq 2\cdot 10^5$。

### Thoughts

根据异或的一个性质：$A\oplus A=0$，则对于一颗异或和为 $x$ 的树，如果其中割掉一棵异或和为 $y$ 的子树，则剩余部分异或和为 $x\oplus y$。

可以发现设整棵树的异或和为 $A$，分成若干个联通块（可以看成「割去子树」），假设所有联通块异或和都为 $B$：

- Case1：**如果分成偶数个联通块，**那么 $A$ 会被异或上奇数个 $B$（相当于一个）形成最后剩余的一个联通块的异或和，必须也是 $B$，也就是 $A \oplus B=B$，则 $A=0$。可以发现这种情况一定有解，因为至少可以删去一条边、分为两个联通块。

- Case2：**如果分成奇数个联通块，**则 $A$ 会被异或上偶数个 $B$（相当于零个），最后结果还是 $A$，则要求 $A=B$。这种情况即要求每个分出的联通块异或和等于 $A$，并且可能分出偶数个子树。

可以用 DFS 传递最少分出的子树，用 `pair<int,int>` 分别传递奇偶情况。

Wrong answer on pretest 2。

### Analysis

Pretest #2 的第 4 组测试数据就叉掉了我的算法：

```
9 4
377804615 522874068 101778092 409548873 334317788 230030759 377804615 295237531 404145046
1 9
4 5
7 3
4 8
3 4
4 6
2 3
9 3
```

![graph](/Users/skywt/Downloads/graph.png)

整棵树异或和是 377804615，以 4 为根的子树异或和为 377804615，而以 3 为根的子树 **去除以 4 为根的子树的部分之后** 异或和也是 377804615。

也就是说，我们分割联通块的过程不能单纯地看成分割子树，其实有非常复杂的过程。



就差一点点！！！从子树的角度考虑，又变得复杂了。大概是太久没做图论，对树的感觉完全丧失了。

和 Case1 一样，对于奇数个联通块的情况，分成任何奇数个联通块都等同于分成三个联通块。我们只需要搜寻能否删除两条边使得形成的三个联通块异或和都为 $A$。只需要搜索深度最大的一条删除的边，删除它再搜索第二条。 

哎，偶数个联通块可以想到 2，奇数个怎么就想不到 3 呢？？



感觉这题很好地体现了一种「从一般到特殊」的过程，一开始想要把所有子树 $n$ 个异或和都枚举作为最终可能的相同异或和，然后发现其实最后的异或和只可能是 $A$；然后想要去找删除的边，然后发现只需要删除最多两条边。这个问题的解决由思考的深入会逐步简化。

## D. Hemose in ICPC ?

### Description

这是一道交互题。

给出一棵树，边是有权的，但是权值未知。定义 $Dist(u,v)$ 为 $u$ 到 $v$ 路径上所有边的权值的最大公因数。你可以按如下方式询问：询问一个点集 $S$，得到 $S$ 中两两节点之间 $Dist$ 的最大值作为回答。最多询问 12 次。要求输出两两之间 $Dist$ 最大的两个点编号。

$2\le n\le 10^3$，边权 $\le 10^9$。

### Thoughts*

没啥 thoughts。应该是二分？

### Analysis

首先发现：要求的 $Dist$ 最大值一定会是某条边的权值（因为 $gcd(a,b)\le min(a,b)$）。事实上我们只需要找到最大的边权即可。

二分，每次找到一条边使得树被分为两个大小相同（或者差 1）的点集，











