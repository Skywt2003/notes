# Codeforces Round #295 (Div. 2)

[Link](https://codeforces.com/contest/520/)

## VC 复盘

前两题大概用了 20min，C 题折腾得比较厉害，还是以前的老毛病：没仔细想好就开始写。之前的几个想法都是有问题的，最后思路也不是特别清晰，也无从论证这个做法的正确性。明显的表现就是最后 AC 的代码里一种特判其实也是一般情况里的。提交代码的时候不是怀着「万无一失」的心态，而是抱着「试试看，希望能过」的心理。这种作风还是要改变呀。

做到 D 题大概只剩下半个多小时了。加上对 multiset 和结构体之类的操作很不熟悉（忘光了），不得不去查了一下资料，CSDN 的东西又全都是错的，半个多小时没能完成 D。并且之后发现关于 D 题的想法还是存在一点点小问题的。

## A. Pangram

## B. Two Buttons

BFS 可做。

## C. DNA Alignment

### Description

定义两个字符串 $s$、$t$ 的距离 $p(s,t)$ 为对于所有 $s$ 轮换了 i 次、$t$ 轮换了 j 次的 i×j 个组合，两个字符串的 $h(s1,t1)$ 之和，$h(s1,t1)$ 指的是 $s1$ 和 $t1$ 两个字符串相同位上字符相同的个数。字符串只包含大写的 `A`、`C`、`G`、`T` 四种字符。

给出字符串 $s$，求出相同位数与其距离最大的字符串 $t$ 的数量。模 1e9+7。

### Analysis

首先对于 $s$ 字符串可以考虑和 $s$ 本身的距离。这个距离是最大的吗？

对于有些字符串，似乎是的。并且可以发现对于两种出现次数一样的字符，将其中一种字符替换为另一种，对距离没有影响。例如 `AATT` 和 `AATT`、`AAAA`、`TTTT`、`ATTT` 等等的距离都是一样且最大的。我们可以把这样的字符串里所有字符都看成一样的。个数是 $cnt^n$

但是如果这样的出现次数相同有多种，例如 `AAAGGGCCTT`，是不是还满足这样的规律呢？显然不是了，对这样的字符串与之距离最大的是 `AAAGGGAAGG` 之类，也就是把所有字符看成出现次数最大的字符（之一）。个数仍然是 $cnt^n$，cnt 指的是出现次数并列最多的字符的个数。

## D. Cubes

### Description

平面直角坐标系里有 m 个 1×1 的正方形（每个以左下角坐标的形式给出），标号为 0 到 m-1。x 轴是地面。保证初始给出的结构是稳定的，即：每个方块要么放在地面上，要么下方或者左下角或者右下角存在方块。

现在 A 和 B 玩取方块的游戏，A 先手。要求每轮拿完之后整个结构仍然是稳定的，最后全部取完。最终拿取方块的顺序形成一个序列，视为一个 m 进制的自然数。A 想要这个数字尽量大，B 要其尽量小，求最后这个数字模 1e9+9。

### Analysis

可以想到一个类似简化版的拓扑的做法：维护一个 set，存储当前所有可以取的方块，A 就取最大的，B 就取最小的。由于每次取最大/最小显然可以让最终结果的数字最大/最小（因为低位无法影响高位），所以这样的贪心做法是正确的。每取出一个方块，就更新这个方块下面的三个方块的可取状态。具体判断是：如果某个方块以上三个方块有任何一个「唯一依赖」于当前方块，则不能取，「唯一依赖」指的是上面的方块下面三个位置存在唯一一个方块（也就是拿走了这个方块，上面的方块就会不稳定）。

但是事实上有一点小问题（被 test 3 叉了），一个加入队列的可取出方块可能在经过一些其他取出操作之后变得不能取出，换句话说取出一个方块 $(x,y)$ 的同时要更新 $(x-2,y)$ 和 $(x+2,y)$。其实可以在每一轮取出 set 头或尾的时候再判断一次能否取出，这样的判断只会带来常数级别的影响。

注意是模 1e9+9 不是 1e9+7！！！被坑到了。

关于 set 的一些用法，CSDN 上抄来抄去的文章基本上都是错的。`s.begin()` 指向首元素，`s.end()` 指向**尾元素的后一个位置**。

## E. Pluses everywhere

### Description

给出一个长度为 n 的数字串，在其中插入 k 个加号可以使之成为合法的表达式（「合法」是指：首位末位不是加号，没有两个加号相连），求出所有这样的表达式的计算结果之和。模 1e9+7。

### Analysis

