# Codeforces Round #743 (Div. 2)

## A. Countdown

## B. Swaps

## C. Book

### Description

一本书有 n 个章节。每个章节可能有若干「前置章节」，理解完所有「前置章节」才能理解此章节。

每次阅读可以按顺序从 1 章节读到 n 并理解所有能够理解的章节。

求出最少的阅读次数，使得理解完所有章节。

多组数据。

### Analysis

如果每次阅读只能理解一个章节，这就直接是拓扑最长路。现在要解决这个一次阅读可以理解多个章节的问题。

理解完章节 i 之后，可以看成：依赖于章节 i 并且序号大于 i 的章节可以在这一次一起阅读，也就是 depth 不用增加。只需要加上关于 depth 的特殊判断就可以了。

#### 两个坑点

太久没写拓扑了，关于 `-1` 的判断一定要考虑「所有点是否都访问过」，而不是仅仅判断「是否包含环」。

多组数据清空数组直接用多个 memset 会 T 飞，我直接手动 1 到 n 清空了。不知道有没有其他快速的办法。

## D. Xor of 3

### Description

给出一个 0/1 序列，每次操作可以从 1 到 n-2 中选择一个 i，然后将 $a_i,a_{i+1},a_{i+2}$ 三个元素都换成 $a_{i} \oplus a_{i+1} \oplus a_{i+2}$ 的值，$\oplus$ 代表异或。

需要使用不多于 n 次的操作使得所有元素都变成 0，要求输出操作。如果不可能，输出 `NO`。

多组数据。

### Analysis

三个 0/1 组合的异或情况是有限的，具体来说，`000`，`011`，`101`，`110` 的结果是 `000`，其他的结果是 `111`。可以发现操作之后 1 的数量的奇偶性不变。

考虑 n 为奇数的构造方法，很难从一开始毫无规律的数列开始构造，我们可以考虑先通过某种固定的操作让这个序列带上某种特定的特征。考虑对每个奇数位实施操作，这样对于任意的奇数 $i$ 都有 $a_i=a_i+1$。$\lfloor n/2 \rfloor$ 次操作完成后最后的 $a_{n}$ 一定是 0，否则奇偶性的条件不满足。那么也有 $a_{n-2}=a_{n-1}=a_n=0$。现在这个序列有了一种规律，我们可以对 $n-4,n-6,\dots,1$ 进行操作，操进行  $\lfloor n/2 \rfloor-1$ 次，做完之后必然使所有数字变成 0。

对于 n 为偶数的情况，我们可以考虑把它分割为两个奇数的序列。找到一个长度为奇数并且包含偶数个 1 的前缀，对其执行上述操作，对于剩下的后缀也执行上述操作。总共有偶数个 1 的时候才有解，所以不可能没有这样的前缀。



证明我是看懂了，但是这个构造到底怎么想到啊……T_T 真的好难……



